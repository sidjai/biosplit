#'Manipulate the input slices into s nice netCDF file
#'
#'Scales the color tag to a single true or false value
#'	Then aggregates the small spacing into the desired spacing
#'	Then changes the projection into unprojected or a user defined projection 
#'	Finally saves the result as a csv readable by surfer (.dat) and the netCDF file
#'
#'@param dirIn The directory with slices of tif files ussually generated by NASS2TIFs()
#'@param pathOut The full file name of the aggregated file, either in .dat or .nc
#'@param cropGrid The input extent and projection with the new spacing that you want
#'@param niceGrid The result grid in the projection that you want
#'
#'@import ncdf
#'@import raster
#'@export
library(ncdf)
library(raster)
rawCrop2nicenc <- function(dirIn,pathOut,cropGrid,niceGrid=""){
	if(!dir.exists(dirIn)){
		stop(paste("Directory:", dirIn, "does not exist or can't be assessed."))
	}
	
	xs <- xFromCol(cropGrid)
	aggxs <- list(left = xs - xres(cropGrid)/2,
								right = xs + xres(cropGrid)/2)
	if(is.character(niceGrid)){
		#default out grid is unprojected lat lon
		niceProj <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
		niceGrid <- projectExtent(cropGrid, niceProj)
	}
		
	rawFiles <- list.files(dirIn,pattern = "tif")
	#Raster definitions start at the top left so need to reverse the list
	rawFiles <- rev(rawFiles)
	tifFiles <- paste(dirIn, rawFiles, sep="/")
	
	
	#tests
	numSlicesIn <- length(rawFiles)
	if (numSlicesIn != nrow(cropGrid)){
		stop(paste("Definition expects", nrow(cropGrid),
							 "while the tifs in", dirIn, "has", numSlicesIn))
	}
	
# 	testRas <- as.logical(raster(rgdal::readGDAL(tifFiles[1], silent = TRUE)))
# 	if(projection(testRas) != projection(cropGrid)){
# 		stop(paste("Projections of cropGrid and tif file is different\n",
# 							 "tif file:", projection(testRas),"\n",
# 							 "cropGrid:", projection(cropGrid)))
# 	}
# 	rm(testRas)
	
	prog <- txtProgressBar(style = 3)
	zs <- vapply(tifFiles,function(x){
		setTxtProgressBar(prog, getTxtProgressBar(prog) + 1/numSlicesIn)
		processCrop(x,aggxs)
	},rep(1,ncol(cropGrid)),USE.NAMES = FALSE)
	
	zs <- as.vector(zs)
	translate <- rasterToPoints(cropGrid)
	
	xyz <- cbind(translate,zs)
	
	
	write.table(xyz,
							file = gsub("nc", "dat", pathOut),
							quote=FALSE,row.names=FALSE,col.names=FALSE)
	
	ras <- rasterFromXYZ(xyz)
	projection(ras) <- projection(cropGrid)
	ras <- projectRaster(ras,niceGrid)
	dataType(ras) <- 'INT4S'
	sult <- try(writeRaster(ras,filename=gsub("dat", "nc", pathOut),
													format="CDF", overwrite=TRUE),silent=TRUE)
	
}



processCrop <- function(gdalSlice,defxs){
	ras <- raster(rgdal::readGDAL(gdalSlice,silent = TRUE))
	top <- ras@extent@ymax #get the top of the slice
	bot <- ras@extent@ymin #get the bottom of the slice
	
	zvals <- vapply(1:length(defxs$left),function(xi){
		ext <- extent(defxs$left[xi], defxs$right[xi], bot, top)
		
		return(sum(as.logical(extract(ras, ext)),na.rm=TRUE))
	},1)
	ras <- 999
	return(zvals)
}

